<?xml version="1.0"?>

<bindings id="emacsWindowBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

<binding id="conkframe">
      <content>
          <xul:deck flex="1">
            <xul:vbox flex="1">
	      <xul:browser flex="1" type="content-primary" pile="0"/>
	      <xul:hbox class="mode-line">
	      <xul:label class="mode-line-label" value="" crop="right" flex="1"/>
              </xul:hbox>
	    </xul:vbox>
	  </xul:deck>
      </content>
      <implementation type="application/x-javascript" implements="nsIDOMXULSelectControlElement, nsIAccessibleProvider">
            <property name="accessible">
              <getter>
              <![CDATA[
                var accService = Components.classes["@mozilla.org/accessibilityService;1"].getService(Components.interfaces.nsIAccessibilityService);
                return accService.createXULGroupboxAccessible(this);
              ]]>
            </getter>
            </property>
            <field name="mCurrentWindow">
	          null
	    </field>
            <field name="mCurrentBrowser">
	          null
	    </field>
	    <field name="mBrowserContainer">
	      document.getAnonymousNodes(this)[0]
            </field>
	    <field name="mProgressListener">
	      null
            </field>
	    <field name="mProgressFilter">
	      null
            </field>

      <property name="mBrowsers"
                onget="return this.mBrowserContainer.getElementsByTagName('browser');"
                readonly="true"/>

      <method name="isSplit">
      <body>
        <![CDATA[
        for (var i=0; i<this.mBrowsers.length; i++) {
	  if (this.mBrowsers[i].parentNode.getAttribute("collapsed") == "false"
	      && this.mBrowsers[i] != this.mCurrentBrowser) {
	      return true;
          }
        }
	return false;
	]]>
      </body>
      </method>
      <method name="setBrowserProgressListener">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
	  try {
            aBrowser.webProgress.addProgressListener(this.mProgressFilter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
} catch(e) {window.alert(e);}
          ]]>
        </body>
      </method>

      <method name="getBrowserAtIndex">
        <parameter name="aIndex"/>
        <body>
          <![CDATA[
            return this.mBrowsers[aIndex];
          ]]>
        </body>
      </method>

      <method name="getBrowserIndex">
        <parameter name="aBrowser"/>
        <body>
          <![CDATA[
           var bs = this.mBrowsers;
           for (var i=0; i<bs.length; i++)
              if (bs[i] == aBrowser)
                return i;
          ]]>
        </body>
      </method>

      <method name="newBrowser">
        <parameter name="aUrl"/>
        <body>
	  <![CDATA[
	  try {
	    if (!aUrl)
	      aUrl = "about:blank";
	      var b = this.makeBrowser();
	    this.mBrowserContainer.appendChild(b);
	    this.setBrowserProgressListener(b.firstChild);
            b.firstChild.loadURIWithFlags(aUrl, nsIWebNavigation.LOAD_FLAGS_NONE, null, null, null);
            this.setCurrentBrowser(b.firstChild);
            return b.firstChild;
} catch(e) {window.alert(e);}
          ]]>
	</body>
      </method>
      <method name="nextBrowser">
        <body>
	  <![CDATA[
	  try {
	    if (this.mCurrentBrowser == null || this.mBrowsers.length <= 1)
	      return;
	    if (this.mCurrentBrowser.parentNode == this.mBrowserContainer.lastChild)
	      this.setCurrentBrowser(this.mBrowserContainer.firstChild.firstChild);
	    else
	      this.setCurrentBrowser(this.mCurrentBrowser.parentNode.nextSibling.firstChild);
} catch(e) {window.alert(e);}
          ]]>
</body>
      </method>
      <method name="prevBrowser">
      <body>
	  <![CDATA[
	  try {
	    if (this.mCurrentBrowser == null || this.mBrowsers.length <= 1)
	      return;

	    if (this.mCurrentBrowser.parentNode == this.mBrowserContainer.firstChild)
	      this.setCurrentBrowser(this.mBrowserContainer.lastChild.firstChild);
	    else
	      this.setCurrentBrowser(this.mCurrentBrowser.parentNode.previousSibling.firstChild);
	  } catch(e) {alert(e); }
          ]]>
</body>
      </method>
      <method name="lastBrowser">
      <body>
	<![CDATA[
	if (this.mBrowsers.length == 1) 
	  return this.mBrowsers[0];
	else
	  return this.getBrowserForPileID(this.getPileTop()-1);
	]]>
      </body>      
      </method>
      <method name="focusBrowser">
        <parameter name="aBrowser"/>
	<body>
	<![CDATA[
	  try {
            function setFocus(element) {
              document.commandDispatcher.suppressFocusScroll = true;
              //Components.lookupMethod(element, "focus").call(element);
              element.focus();
              document.commandDispatcher.suppressFocusScroll = false;
            }

    	    this.mCurrentBrowser.focusedWindow = document.commandDispatcher.focusedWindow;
	    this.mCurrentBrowser.focusedElement = document.commandDispatcher.focusedElement;
	    this.mCurrentBrowser.setAttribute("type", "content");

	    // Update the pile
	    this.bringToTop(aBrowser, this.mCurrentBrowser);
	    this.mCurrentBrowser = aBrowser;
            aBrowser.setAttribute("type", "content-primary");

            if (aBrowser.focusedElement) {
              try {
                setFocus(aBrowser.focusedElement);
              } catch (e) {
                setFocus(aBrowser.focusedWindow);
              }
            }
            else if (aBrowser.focusedWindow)
              setFocus(aBrowser.focusedWindow);
            else // new tab, focus our new content area
              setTimeout(setFocus, 0, window.content);
	  } catch(e) {alert(e);}
	]]>
	</body>
      </method>
      <method name="setCurrentBrowser">
        <parameter name="aBrowser"/>
        <body>
	  <![CDATA[
	  try{
	    var newBrowser = aBrowser;

	    if (this.mCurrentBrowser == newBrowser) {
	      return;
	    }

            this.mBrowserContainer.selectedIndex = this.getBrowserIndex(newBrowser);

	    this.focusBrowser(newBrowser);
	    } catch(e) {alert(e);}
          ]]>	    	
        </body>
      </method>
      <method name="killBrowser">
        <parameter name="aBrowser"/>
	<body>
	  <![CDATA[
	   try {
	    if (this.mBrowsers.length <= 1)
	      return;

            // make sure we can kill the browser
            var ds = aBrowser.docShell;
            if (ds.contentViewer && !ds.contentViewer.permitUnload())
              return;

	    // pick the next browser to be the new current browser
            if (this.mCurrentBrowser == aBrowser) {
	      var newBrowser = this.lastBrowser();
              var par = aBrowser.parentNode;
	      this.setCurrentBrowser(newBrowser);
              aBrowser.destroy();
	      this.mBrowserContainer.removeChild(par);
              this.mBrowserContainer.selectedIndex = this.getBrowserIndex(this.mCurrentBrowser);
              // this creates a gap so fill it.
	      this.mCurrentBrowser.setAttribute('pile', this.mCurrentBrowser.getAttribute('pile')-1);
            } else {
              var par = aBrowser.parentNode;
              this.pushPileDown (aBrowser.getAttribute ('pile'), this.mCurrentBrowser);
              aBrowser.destroy();
	      this.mBrowserContainer.removeChild(par);
              this.mBrowserContainer.selectedIndex = this.getBrowserIndex(this.mCurrentBrowser);
            }
	    } catch(e) {window.alert(e);}
          ]]>
	</body>
      </method>
      <method name="killCurrentBrowser">
        <body>
	<![CDATA[
	  this.killBrowser(this.mCurrentBrowser);
	]]>
	</body>
      </method>
      <method name="setProgressListener">
        <parameter name="aListener"/>
	<parameter name="aMask"/>
	<body>
          <![CDATA[
	  try {
	    if (this.mProgressListener)
	      this.mProgressFilter.removeProgressListener(this.mProgressListener);
	    this.mProgressListener = aListener;
	    if (this.mProgressListener) {
	      this.mProgressFilter.addProgressListener(this.mProgressListener, aMask);
	    }
} catch(e) {window.alert(e);}
	  ]]>
	</body>
      </method>
      <method name="getBrowserNames">
        <body>
	<![CDATA[
	try {
	  var bs = this.mBrowsers;
	  var names = [];
	  for (var i=0; i<bs.length; i++) {
	    names.push(bs[i].webNavigation.currentURI.spec);
	  }
	  return names;
        } catch(e) {log ("getBrowserNames: " + e);}
	]]>
	</body>
      </method>
<!--       <method name="split"> -->
<!--       <parameter name="otherBrowser"/> -->
<!--       <body> -->
<!--       <![CDATA[ -->
<!--       try { -->
<!--         if (otherBrowser == this.mCurrentBrowser) { -->
<!-- 	  return; -->
<!--         } -->
<!--         // Make sure there isn't already a split -->
<!-- 	if (this.isSplit()) -->
<!-- 	  return; -->
<!-- 	this.mCurrentBrowser.parentNode.setAttribute("ordinal", "0"); -->
<!-- 	otherBrowser.parentNode.setAttribute("ordinal", "1"); -->
<!-- 	otherBrowser.parentNode.setAttribute("collapsed", "false"); -->
<!--       } catch(e) {alert(e);} -->
<!--       ]]> -->
<!--       </body> -->
<!--       </method> -->
<!--       <method name="removeSplit"> -->
<!--       <body> -->
<!--       <![CDATA[ -->
<!--       try { -->
<!--         for (var i=0; i<this.mBrowsers.length; i++) { -->
<!-- 	  if (this.mBrowsers[i].parentNode.getAttribute("collapsed") == "false" -->
<!-- 	      && this.mBrowsers[i] != this.mCurrentBrowser) { -->
<!-- 	      this.mBrowsers[i].parentNode.setAttribute("collapsed", "true"); -->
<!-- 	  } -->
<!--         } -->
<!--       } catch(e) {alert(e);} -->
<!--       ]]> -->
<!--       </body> -->
<!--       </method> -->
<!--       <method name="focusOther"> -->
<!--       <body> -->
<!--       <![CDATA[ -->
<!--       try { -->
<!--         for (var i=0; i<this.mBrowsers.length; i++) { -->
<!-- 	  if (this.mBrowsers[i].parentNode.getAttribute("collapsed") == "false" -->
<!-- 	      && this.mBrowsers[i] != this.mCurrentBrowser) { -->
<!-- 	      this.focusBrowser(this.mBrowsers[i]); -->
<!-- 	      return; -->
<!-- 	  } -->
<!--         } -->
<!--       } catch(e) {alert(e);} -->
<!--       ]]> -->
<!--       </body> -->
<!--       </method> -->
<!--       <method name="flip"> -->
<!--       <body> -->
<!-- 	<![CDATA[ -->
<!-- 	try { -->
<!-- 	if (this.mBrowserContainer.getAttribute("orient") == "horizontal") -->
<!-- 	  this.mBrowserContainer.setAttribute("orient", "vertical"); -->
<!-- 	else -->
<!-- 	  this.mBrowserContainer.setAttribute("orient", "horizontal"); -->
<!-- 	} catch(e) {alert(e);} -->
<!--       ]]> -->
<!--       </body> -->
<!--       </method> -->
      <method name="pushPileDown">
      <parameter name="a"/>
      <parameter name="b"/>
      <body>
        <![CDATA[
	  for(i=0; i<this.mBrowsers.length; i++) {
	    var p = this.mBrowsers[i].getAttribute('pile');
	    if (p > a && p <= b)
	      this.mBrowsers[i].setAttribute('pile', p-1);
	    }    
	  }
	]]>
	</body>
      </method>
      <method name="bringToTop">
      <parameter name="b"/>
      <parameter name="oldb"/>
      <body>
        <![CDATA[
	  bp = b.getAttribute('pile');
	  oldbp = oldb.getAttribute('pile');
	  // is b already higher in the pile than oldb?
	  if (bp > oldbp)
	    return;
	  this.pushPileDown(bp, oldbp);
	  b.setAttribute('pile', oldbp);
	]]>
      </body>
      </method>
      <method name="getPileTop">
        <body>
	  <![CDATA[
	  var max = this.mBrowsers[0].getAttribute('pile');
	  for(i=1; i<this.mBrowsers.length; i++) {
	    var p = this.mBrowsers[i].getAttribute('pile');
	    max = p>max ? p:max;
	  }
	  return max;
	}
      ]]>
      </body>
      </method>
      <method name="getBrowserForPileID">
        <parameter name="id"/>
        <body>
	  <![CDATA[
	  for(i=0; i<this.mBrowsers.length; i++) {
	    if (id == this.mBrowsers[i].getAttribute("pile"))
	      return this.mBrowsers[i];
	  }
	  return null;
	}
      ]]>
      </body>
      </method>
      <method name="makeBrowser">
      <body>
      <![CDATA[
      try {
        var b = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "browser"); 
	b.setAttribute("type", "content");
	b.setAttribute("flex", "1");
        if (this.mBrowsers.length == 0)
  	  b.setAttribute("pile", 1);
        else
	  b.setAttribute("pile", parseInt(this.getPileTop())+1);
	b.__numberedLinks_state = default_show_numbered_links;
	b.__numberedImages_state = default_show_numbered_images;
	var v = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "vbox"); 
	v.setAttribute("flex", "100");
	var s = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "hbox");
	s.setAttribute("class", "mode-line");
	var sp = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "label"); 
	sp.setAttribute("value", "");
	sp.setAttribute("flex", "1");
	sp.setAttribute("class", "mode-line-label");
	sp.setAttribute("crop", "right");
	s.appendChild(sp);
	v.appendChild(b);
	v.appendChild(s);
	return v;
      } catch(e) {alert(e);}
      ]]>
      </body>
      </method>
      <property name="modeLine"
                onget="return this.mCurrentBrowser.nextSibling.firstChild"
		readonly="true"/>
      <property name="docShell"
                onget="return this.mCurrentBrowser.docShell"
                readonly="true"/>

      <property name="webNavigation"
                onget="return this.mCurrentBrowser.webNavigation"
                readonly="true"/>

      <property name="webProgress"
                readonly="true"
                onget="return this.mCurrentBrowser.webProgress"/>

      <property name="markupDocumentViewer"
                onget="return this.mCurrentBrowser.markupDocumentViewer;"
                readonly="true"/>

      <property name="contentDocument"
                onget="return this.mCurrentBrowser.contentDocument;"
                readonly="true"/>
      <property name="curbrow"
                onget="return this.mBrowserContainer;"
                readonly="true"/>

      <property name="browsers"
                onget="return this.mBrowserContainer.getElementsByTagName('browser');"
                readonly="true"/>

      <property name="numberedLinks"
                onget="return this.mCurrentBrowser.__numberedLinks_state;"
		onset="this.mCurrentBrowser.__numberedLinks_state = val; return val;"/>
      <property name="numberedImages"
                onget="return this.mCurrentBrowser.__numberedImages_state;"
		onset="this.mCurrentBrowser.__numberedImages_state = val; return val;"/>

      <constructor>
        <![CDATA[
	  this.mCurrentBrowser = this.getBrowserAtIndex(0);
	  this.numberedLinks = true;
	  this.mProgressFilter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                                           .createInstance(Components.interfaces.nsIWebProgress);
          this.setBrowserProgressListener(this.mCurrentBrowser);
        ]]>
      </constructor>
      </implementation>
</binding>
</bindings>
